#!/usr/bin/env node
// -*- mode: js -*-
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */

/*
 * Copyright (c) 2015, Joyent, Inc.
 */
var adm = require('../lib/adm');
var assert = require('assert');
var cmdln = require('cmdln');
var fs = require('fs');
var util = require('util');
var path = require('path');
var tab = require('tab');
var sprintf = require('extsprintf').sprintf;
var VError = require('verror');

/*
 * For consistency in option definitions, any options used by more than one
 * subcommand should be defined here.  Subcommands using these options refer to
 * this definition.
 */
var commonOptions = {
    'help': {
        names: ['help', 'h'],
        type: 'bool',
        help: 'Show this help'
    },
    'ignorePrompts': {
        names: ['ignorePrompts', 'y'],
        type: 'bool',
        helpArg: 'IGNORE_PROMPTS',
        help: 'Skip confirmation prompts (can be dangerous) ',
        default: false
    },
    'json': {
        names: ['json', 'j'],
        type: 'bool',
        help: 'Emit stable JSON output'
    },
    'shard': {
        names: ['shard', 's'],
        type: 'string',
        helpArg: 'SHARD',
        help: 'Name of the manatee shard',
        default: process.env.SHARD
    },
    'zk': {
        names: ['zk', 'z'],
        type: 'string',
        helpArg: 'ZOOKEEPER_URL',
        help: 'The zookeeper connection string. (e.g., 127.0.0.1:2181)',
        default: process.env.ZK_IPS
    }
};

function ManateeAdm() {
    cmdln.Cmdln.call(this, {
        name: 'manatee-adm',
        desc: 'Inspect and administer Manatee'
    });

    this.arg0 = 'manatee-adm';
}
util.inherits(ManateeAdm, cmdln.Cmdln);

/**
 * Emit an error message, then the usage message, and then exit.
 */
ManateeAdm.prototype.usage = function (message, subcmd, cb)
{
    var self = this;

    console.error('%s: %s', self.arg0, message);
    self.do_help('help', {}, [subcmd], function () {
        process.exit(2);
    });

    assert.ok(false, 'internal error: did not expect do_help() to return');
};

/**
 * Check for a required command-line option.  If option "option" was not
 * specified in "opts", then print an error message, then the usage message,
 * then exit.  This function does not return on failure.
 */
ManateeAdm.prototype.checkRequiredOption = function (subcmd, opts, option, cb)
{
    var self = this;

    if (!opts[option]) {
        self.usage('option is required: --' + option, subcmd, cb);
    }
};

/*
 * Checks whether the "help" option was specified.  If so, print the usage
 * message and exit.  This function does not return if it prints the help
 * message.
 */
ManateeAdm.prototype.checkHelpRequested = function (subcmd, opts, cb)
{
    var self = this;

    if (opts.help) {
        self.do_help('help', {}, [subcmd], cb);
        assert.ok(false, 'internal error: did not expect do_help() to return');
    }
};

/**
 * Prints the version for this manatee-adm (and, hence, manatee itself).  Taken
 * directly from the package.json.
 */
ManateeAdm.prototype.do_version = function (subcmd, opts, args, cb) {
    var self = this;

    self.checkHelpRequested(subcmd, opts, cb);

    var file = path.resolve(path.dirname(__dirname), 'package.json');
    var error;
    try {
        var s = fs.readFileSync(file);
        var j = JSON.parse(s);
        console.log(j.version);
    } catch (err) {
        error = err;
    }
    return (cb(error));
};
ManateeAdm.prototype.do_version.options = [ commonOptions.help ];
ManateeAdm.prototype.do_version.help = (
    'Shows the version of manatee, taken from the package.json. \n' +
    '\n' +
    'Usage:\n' +
    '    {{name}} version [OPTIONS]\n' +
    '\n' +
    '{{options}}'
);

/**
 * Display the current status of the manatee shard(s).
 */
ManateeAdm.prototype.do_status = function (subcmd, opts, args, cb) {
    var self = this;

    self.checkHelpRequested(subcmd, opts, cb);
    self.checkRequiredOption(subcmd, opts, 'zk', cb);

    console.error('note: "%s status" is deprecated.  See "%s help pg-status".',
        self.arg0, self.arg0);
    adm.status(opts, function (err, status) {
        if (err) {
            return cb(err);
        } else {
            console.log(JSON.stringify(status));
            return cb();
        }
    });
};
ManateeAdm.prototype.do_status.options = [
    commonOptions.help,
    {
        names: ['legacyOrderMode', 'l'],
        type: 'bool',
        helpArg: 'LEGACY_ORDER_MODE',
        help: 'Show what the status is based on what is in the ZK ' +
            'election path rather than what is in the cluster state object.',
        default: false
    },
    commonOptions.shard,
    commonOptions.zk
];
ManateeAdm.prototype.do_status.help = (
    '[LEGACY] Show status of a manatee shard. \n' +
    '\n' +
    'Usage:\n' +
    '    {{name}} status [OPTIONS]\n' +
    '\n' +
    '{{options}}'
);

/**
 * Display the current postgres status for this shard.  This is a more useful
 * display of the overall shard status.
 */
ManateeAdm.prototype.do_pg_status = function (subcmd, opts, args, cb) {
    var self = this;
    var period, count;

    self.checkHelpRequested(subcmd, opts, cb);
    self.checkRequiredOption(subcmd, opts, 'shard', cb);
    self.checkRequiredOption(subcmd, opts, 'zk', cb);

    if (args.length > 2) {
        self.usage('unexpected arguments: ' + args.slice(2), subcmd, cb);
    }

    period = null;
    count = null;
    if (args.length > 0) {
        period = parseInt(args[0], 10);
        if (isNaN(period) || period < 1) {
            self.usage('invalid period: "' + args[0] + '"', subcmd, cb);
        }

        if (args.length > 1) {
            count = parseInt(args[1], 10);
            if (isNaN(count) || count < 1) {
                self.usage('invalid count: "' + args[1] + '"', subcmd, cb);
            }
        }
    }

    doPgStatusIter(opts, period, count, cb);
};

ManateeAdm.prototype.do_pg_status.options = [
    commonOptions.help,
    commonOptions.json,
    commonOptions.shard,
    commonOptions.zk
];
ManateeAdm.prototype.do_pg_status.help = (
    'Show the postgres status of a manatee shard. \n' +
    '\n' +
    'Usage:\n' +
    '    {{name}} pg-status [OPTIONS]\n' +
    '\n' +
    '{{options}}'
);

/*
 * Executes "count" iterations of the "pg-status" command, once every "period"
 * seconds, and invoke "cb" on completion.  If "count" is null and "period" is
 * not null, repeat forever.  If "period" is null, don't repeat at all.  This
 * mimics the behavior of the various *stat commands (e.g., mpstat(1M),
 * prstat(1M), and the like).
 */
function doPgStatusIter(opts, period, count, cb)
{
    var self = this;

    adm.loadClusterDetails(opts, function (err, status) {
        if (err) {
            console.error('%s: %s', self.arg0, err.message);
        } else if (opts.json) {
            console.log(status.toJson());
        } else {
            emitClusterDetails(opts, status);
        }

        if (period === null || count == 1)
            return cb(err);

        setTimeout(doPgStatusIter, period * 1000, opts, period, count - 1, cb);
    });
}

/*
 * Given a complete cluster status as returned by adm.loadClusterDetails(),
 * print a human-readable, short summary of the state.
 */
function emitClusterDetails(opts, status)
{
    var columns, rows;

    columns = [ {
        'label': 'ROLE',
        'width': 7
    }, {
        'label': 'HOST',
        'width': 8
    }, {
        'label': 'PG',
        'align': 'left',
        'width': 4
    }, {
        'label': 'REPL',
        'width': 5
    }, {
        'label': 'SENT',
        'width': 10
    }, {
        'label': 'WRITE',
        'width': 10
    }, {
        'label': 'FLUSH',
        'width': 10
    }, {
        'label': 'REPLAY',
        'width': 10
    }, {
        'label': 'LAG',
        'width': 6
    } ];

    rows = [];
    rows.push(rowForPeer('primary', status.pgs_peers[status.pgs_primary]));
    if (status.pgs_sync) {
        rows.push(rowForPeer('sync', status.pgs_peers[status.pgs_sync]));
    }

    status.pgs_asyncs.forEach(function (id) {
        rows.push(rowForPeer('async', status.pgs_peers[id]));
    });

    tab.emitTable({
        'columns': columns,
        'rows': rows
    });

    if (status.pgs_errors.length > 0) {
        console.log('\nCRITICAL ERRORS:');
        status.pgs_errors.forEach(function (err) {
            console.log('    %s', err.message);
        });
        console.log('');
    }

    if (status.pgs_warnings.length > 0) {
        console.log('\nWARNINGS:');
        status.pgs_warnings.forEach(function (err) {
            console.log('    %s', err.message);
        });
        console.log('');
    }
}

/*
 * Returns an object describing a single row emitted by by emitClusterDetails().
 */
function rowForPeer(role, peer)
{
    var rv = {};

    rv['ROLE'] = role;
    rv['HOST'] = peer.pgp_label;

    if (peer.pgp_pgerr !== null) {
        rv['PG'] = 'fail';
        rv['REPL'] = '-';
        rv['SENT'] = '-';
        rv['WRITE'] = '-';
        rv['FLUSH'] = '-';
        rv['REPLAY'] = '-';
        rv['LAG'] = '-';
        return (rv);
    }

    rv['PG'] = 'ok';
    rv['LAG'] = pgDuration(peer.pgp_lag);

    if (peer.pgp_repl === null || !peer.pgp_repl.sync_state) {
        rv['REPL'] = '-';
        rv['SENT'] = '-';
        rv['WRITE'] = '-';
        rv['FLUSH'] = '-';
        rv['REPLAY'] = '-';
        return (rv);
    }

    rv['REPL'] = peer.pgp_repl.sync_state;
    rv['SENT'] = peer.pgp_repl.sent_location;
    rv['WRITE'] = peer.pgp_repl.write_location;
    rv['FLUSH'] = peer.pgp_repl.flush_location;
    rv['REPLAY'] = peer.pgp_repl.replay_location;
    return (rv);
}

/*
 * Given a postgres time duration object "lag", which may have properties like
 * "minutes", "seconds", and the like, return a human readable summary of the
 * duration, like "87m12s".  If the object is null, returns "-".  If the time is
 * not known, returns "?".
 */
function pgDuration(lag)
{
    var minutes, seconds, key;

    if (lag === null)
        return ('-');

    minutes = lag.minutes || 0;
    seconds = lag.seconds || 0;
    for (key in lag) {
        switch (key) {
        case 'days':
            minutes += lag[key] * 24 * 60;
            break;

        case 'hours':
            minutes += lag[key] * 60;
            break;

        case 'minutes':
        case 'seconds':
            break;

        default:
            /*
             * The node-pg-types code that parses postgres intervals implies
             * that it could produce keys for "months" or "years", but
             * empirically it doesn't seem to.  That's a relief (and probably
             * not accidental), since the number of minutes in these units is
             * not constant.  If we get something we don't know about, indicate
             * this to the user.
             */
            return ('?');
        }
    }

    return (sprintf('%dm%02ds', minutes, seconds));
}


/**
 * Display the current cluster state.
 */
ManateeAdm.prototype.do_state = function (subcmd, opts, args, cb) {
    var self = this;

    self.checkHelpRequested(subcmd, opts, cb);
    self.checkRequiredOption(subcmd, opts, 'shard', cb);
    self.checkRequiredOption(subcmd, opts, 'zk', cb);

    adm.state(opts, function (err, state) {
        if (err) {
            return cb(err);
        } else {
            console.log(JSON.stringify(state));
            return cb();
        }
    });
};
ManateeAdm.prototype.do_state.options = [
    commonOptions.help,
    commonOptions.shard,
    commonOptions.zk
];
ManateeAdm.prototype.do_state.help = (
    'Show the cluster state stored in ZK for this shard. \n' +
    '\n' +
    'Usage:\n' +
    '    {{name}} state [OPTIONS]\n' +
    '\n' +
    '{{options}}'
);

/**
 * Display the current (raw) active nodes for a shard.
 */
ManateeAdm.prototype.do_active = function (subcmd, opts, args, cb) {
    var self = this;

    self.checkHelpRequested(subcmd, opts, cb);
    self.checkRequiredOption(subcmd, opts, 'shard', cb);
    self.checkRequiredOption(subcmd, opts, 'zk', cb);

    adm.active(opts, function (err, active) {
        if (err) {
            return cb(err);
        } else {
            console.log(JSON.stringify(active));
            return cb();
        }
    });
};
ManateeAdm.prototype.do_active.options = [
    commonOptions.help,
    commonOptions.shard,
    commonOptions.zk
];
ManateeAdm.prototype.do_active.help = (
    'Display the current active peers for a shard. \n' +
    'Since this displays exactly what is in zookeeper, this may show\n' +
    'multiple entries for the same manatee.\n' +
    '\n' +
    'Usage:\n' +
    '    {{name}} active [OPTIONS]\n' +
    '\n' +
    '{{options}}'
);

/**
 * Backfill the cluster state.
 */
ManateeAdm.prototype.do_state_backfill = function (subcmd, opts, args, cb) {
    var self = this;

    self.checkHelpRequested(subcmd, opts, cb);
    self.checkRequiredOption(subcmd, opts, 'shard', cb);
    self.checkRequiredOption(subcmd, opts, 'zk', cb);

    adm.stateBackfill(opts, function (err, state) {
        if (err) {
            return cb(err);
        } else {
            console.log('Ok.');
            return cb();
        }
    });
};
ManateeAdm.prototype.do_state_backfill.options = [
    commonOptions.help,
    commonOptions.shard,
    commonOptions.ignorePrompts,
    commonOptions.zk
];
ManateeAdm.prototype.do_state_backfill.help = (
    'Backfill the cluster state for the shard.\n' +
    '\n' +
    '!!! WARNING !!! \n' +
    'This will only work when no cluster state has been written. \n' +
    'It is only to be used when moving to Manatee using the persistent \n' +
    'cluster state in ZK. \n' +
    '\n' +
    'This tool may backfill the cluster state in a surprising order: \n' +
    'Primary -> Primary, Async -> Sync, Sync -> Async' +
    'The reason for this is so that when the Async is deployed first, it \n' +
    'will set itself up as a sync, then when the sync is deployed it will \n' +
    'set itself up as async.  This facilitates the migration to using \n' +
    'cluster state rather than election order to decide topology. \n' +
    '\n' +
    'Usage:\n' +
    '    {{name}} state [OPTIONS]\n' +
    '\n' +
    '{{options}}'
);

/**
 * Check the status of a manatee lock
 */
ManateeAdm.prototype.do_check_lock = function (subcmd, opts, args, cb) {
    var self = this;

    self.checkHelpRequested(subcmd, opts, cb);
    self.checkRequiredOption(subcmd, opts, 'path', cb);
    self.checkRequiredOption(subcmd, opts, 'zk', cb);

    adm.checkLock(opts, function (err, stat) {
        if (err || stat) {
            return cb(new Error('lock exists or unable to get lock'));
        }

        return cb();
    });
};
ManateeAdm.prototype.do_check_lock.options = [
    commonOptions.help,
    {
        names: ['path', 'p'],
        type: 'string',
        helpArg: 'LOCK_PATH',
        help: 'The manatee lock path in ZK'
    },
    commonOptions.zk
];
ManateeAdm.prototype.do_check_lock.help = (
    'Check the status of a manatee lock. \n' +
    '\n' +
    'Usage:\n' +
    '    {{name}} check_lock [OPTIONS]\n' +
    '\n' +
    '{{options}}'
);


/**
 * Get the state transition history of the shard.
 */
ManateeAdm.prototype.do_history = function (subcmd, opts, args, cb) {
    var self = this;
    var histopts;

    self.checkHelpRequested(subcmd, opts, cb);
    self.checkRequiredOption(subcmd, opts, 'shard', cb);
    self.checkRequiredOption(subcmd, opts, 'zk', cb);

    if (opts.sort != 'zkSeq' && opts.sort != 'time') {
        self.usage('-s / --sort must be one of "zkSeq" or "time"', subcmd, cb);
    }

    histopts = {
        'zk': opts.zk,
        'shard': opts.shard,
        'sortByTime': opts.sort == 'time'
    };

    adm.history(histopts, function (err, events) {
        var rows, columns, hostwidth;

        if (err) {
            return cb(err);
        }

        if (opts.json) {
            events.forEach(function (evt) {
                console.log(JSON.stringify({
                    'zkSeq': evt['zkSeq'],
                    'time': evt['time'].toISOString(),
                    'state': evt['state']
                }));
            });
            cb();
            return;
        }

        hostwidth = opts.showFullHostnames ? 36 : 8;
        columns = [ {
            'label': 'TIME',
            'width': 24
        }, {
            'label': 'G#',
            'align': 'right',
            'width': 2
        }, {
            'label': 'MODE',
            'width': 5
        }, {
            'label': 'FRZ',
            'width': 3
        }, {
            'label': 'PRIMARY',
            'width': hostwidth
        }, {
            'label': 'SYNC',
            'width': hostwidth
        }, {
            'label': 'ASYNC',
            'width': hostwidth
        }, {
            'label': 'DEPOSED',
            'width': hostwidth
        } ];

        if (opts.verbose) {
            columns.push({ 'label': 'SUMMARY' });
        }

        rows = events.map(function (evt) {
            var st, p, s, a, d;

            st = evt['state'];
            p = st['primary']['zoneId'];
            s = st['sync'] !== null ? st['sync']['zoneId'] : '-';
            a = st['async'].length === 0 ? '-' :
                st['async'].map(function (async) {
                    if (opts.showFullHostnames)
                        return (async['zoneId']);
                    return (async['zoneId'].substr(0, 8));
                });
            d = st['deposed'].length === 0 ? '-' :
                st['deposed'].map(function (deposed) {
                    if (opts.showFullHostnames)
                        return (deposed['zoneId']);
                    return (deposed['zoneId'].substr(0, 8));
                });

            if (!opts.showFullHostnames) {
                p = p.substr(0, 8);
                s = s.substr(0, 8);
            }

            return ({
                'TIME': evt['time'].toISOString(),
                'G#': st['generation'],
                'MODE': st['oneNodeWriteMode'] ? 'singl' : 'multi',
                'FRZ': st['freeze'] ? 'frz' : '-',
                'PRIMARY': p,
                'SYNC': s,
                'ASYNC': a,
                'DEPOSED': d,
                'SUMMARY': evt['comment']
            });
        });

        tab.emitTable({
            'columns': columns,
            'rows': rows
        });

        return cb();
    });
};
ManateeAdm.prototype.do_history.options = [
    commonOptions.help,
    commonOptions.json,
    commonOptions.shard,
    {
        names: ['showFullHostnames'],
        type: 'bool',
        help: 'Show full hostnames (instead of abbreviated versions)'
    },
    {
        names: [ 'sort' ],
        type: 'string',
        helpArg: 'SORTFIELD',
        help: 'Sort field (either "zkSeq" (default) or "time")',
        default: 'zkSeq'
    },
    {
        names: [ 'verbose', 'v' ],
        type: 'bool',
        help: 'Show human-readable summary of each event'
    },
    commonOptions.zk
];
ManateeAdm.prototype.do_history.help = (
    'Displays history of cluster state changes for this shard. \n' +
    '\n' +
    'Usage:\n' +
    '    {{name}} history [OPTIONS]\n' +
    '\n' +
    '{{options}}'
);

/**
 * Rebuild a manatee peer in a shard.
 */
ManateeAdm.prototype.do_rebuild = function (subcmd, opts, args, cb) {
    var self = this;

    self.checkHelpRequested(subcmd, opts, cb);
    self.checkRequiredOption(subcmd, opts, 'config', cb);
    self.checkRequiredOption(subcmd, opts, 'zk', cb);

    try {
        var cfg = JSON.parse(fs.readFileSync(opts.config, 'utf8'));
        opts.config = cfg;
    } catch (e) {
        return cb(e);
    }
    adm.rebuild(opts, function (err) {
        if (!err) {
            console.log('Rebuild successful');
        }
        return (cb(err));
    });
};
ManateeAdm.prototype.do_rebuild.options = [
    commonOptions.help,
    {
        names: ['config', 'c'],
        type: 'string',
        helpArg: 'CONFIG',
        help: 'The path to the manatee sitter config to list',
        default: process.env.MANATEE_SITTER_CONFIG
    },
    commonOptions.ignorePrompts,
    commonOptions.zk
];
ManateeAdm.prototype.do_rebuild.help = (
    'Rebuild a manatee zone. \n' +
    '\n' +
    'Usage:\n' +
    '    {{name}} rebuild [OPTIONS]\n' +
    '\n' +
    '{{options}}'
);

/**
 * Freezes a manatee's cluster state so that it won't make any state
 * transitions.
 */
ManateeAdm.prototype.do_freeze = function (subcmd, opts, args, cb) {
    var self = this;

    self.checkHelpRequested(subcmd, opts, cb);
    self.checkRequiredOption(subcmd, opts, 'reason', cb);
    self.checkRequiredOption(subcmd, opts, 'shard', cb);
    self.checkRequiredOption(subcmd, opts, 'zk', cb);

    adm.freeze(opts, function (err) {
        if (err) {
            return cb(err);
        }

        console.log('Frozen.');
        return cb();
    });
};
ManateeAdm.prototype.do_freeze.options = [
    commonOptions.help,
    {
        names: ['reason', 'r'],
        type: 'string',
        helpArg: 'REASON',
        help: 'The reason this shard is being frozen'
    },
    commonOptions.shard,
    commonOptions.zk
];
ManateeAdm.prototype.do_freeze.help = (
    'Freeze a shard\'s topology. \n' +
    '\n' +
    'Usage:\n' +
    '    {{name}} freeze [OPTIONS]\n' +
    '\n' +
    '{{options}}'
);

/**
 * Unfreezes a manatee's cluster state so that it will make state transitions.
 */
ManateeAdm.prototype.do_unfreeze = function (subcmd, opts, args, cb) {
    var self = this;

    self.checkHelpRequested(subcmd, opts, cb);
    self.checkRequiredOption(subcmd, opts, 'shard', cb);
    self.checkRequiredOption(subcmd, opts, 'zk', cb);

    adm.unfreeze(opts, function (err) {
        if (err) {
            return cb(err);
        }

        console.log('Unfrozen.');
        return cb();
    });
};
ManateeAdm.prototype.do_unfreeze.options = [
    commonOptions.help,
    commonOptions.shard,
    commonOptions.zk
];
ManateeAdm.prototype.do_unfreeze.help = (
    'Unfreeze a shard\'s topology. \n' +
    '\n' +
    'Usage:\n' +
    '    {{name}} unfreeze [OPTIONS]\n' +
    '\n' +
    '{{options}}'
);

/**
 * Sets one node write mode.
 */
ManateeAdm.prototype.do_set_onwm = function (subcmd, opts, args, cb) {
    var self = this;

    self.checkHelpRequested(subcmd, opts, cb);
    self.checkRequiredOption(subcmd, opts, 'mode', cb);
    self.checkRequiredOption(subcmd, opts, 'shard', cb);
    self.checkRequiredOption(subcmd, opts, 'zk', cb);

    opts.mode = opts.mode.toLowerCase();
    if (['on', 'off'].indexOf(opts.mode) === -1) {
        self.do_help('help', {}, [subcmd], cb);
    }

    adm.setOnwm(opts, function (err) {
        if (err) {
            return cb(err);
        }

        console.log('One Node Write Mode set to: ' + opts.mode);
        return cb();
    });
};
ManateeAdm.prototype.do_set_onwm.options = [
    commonOptions.help,
    commonOptions.ignorePrompts,
    {
        names: ['mode', 'm'],
        type: 'string',
        helpArg: 'MODE',
        help: 'Must be either "on" or "off"'
    },
    commonOptions.shard,
    commonOptions.zk
];
ManateeAdm.prototype.do_set_onwm.help = (
    'Set one node write mode. \n' +
    '\n' +
    '!!! WARNING !!!\n' +
    'Do not set or disable one node write mode unless you are sure you\n' +
    'know what you\'re doing.  In order for one node write mode to be\n' +
    'set, the state must match what is in your configuration files for\n' +
    'Manatee.\n' +
    '\n' +
    'Usage:\n' +
    '    {{name}} set_onwm [OPTIONS]\n' +
    '\n' +
    '{{options}}'
);

/**
 * Removes deposed nodes.
 */
ManateeAdm.prototype.do_remove_deposed = function (subcmd, opts, args, cb) {
    var self = this;

    self.checkHelpRequested(subcmd, opts, cb);
    self.checkRequiredOption(subcmd, opts, 'shard', cb);
    self.checkRequiredOption(subcmd, opts, 'zk', cb);

    if (!opts.ip && !opts.zonename) {
        self.checkRequiredOption(subcmd, opts, 'config', cb);

        try {
            var cfg = JSON.parse(fs.readFileSync(opts.config, 'utf8'));
            opts.zonename = cfg.zoneId;
        } catch (e) {
            return cb(e);
        }
    }

    adm.removeDeposed(opts, function (err) {
        if (err) {
            return cb(err);
        }

        console.log('Ok.');
        return cb();
    });
};
ManateeAdm.prototype.do_remove_deposed.options = [
    commonOptions.help,
    {
        names: ['config', 'c'],
        type: 'string',
        helpArg: 'CONFIG',
        help: 'The path to the manatee sitter config',
        default: process.env.MANATEE_SITTER_CONFIG
    },
    {
        names: ['ip', 'i'],
        type: 'string',
        helpArg: 'IP',
        help: 'The ip of the node to remove'
    },
    {
        names: ['zonename', 'n'],
        type: 'string',
        helpArg: 'ZONENAME',
        help: 'The zonename of the node to remove'
    },
    commonOptions.shard,
    commonOptions.zk
];
ManateeAdm.prototype.do_remove_deposed.help = (
    'Moves a node out of the list of deposed manatees. \n' +
    '\n' +
    'After a primary has been deposed by a sync, the primary enters into a\n' +
    'deposed state.  Remove it from the deposed list after it has been\n' +
    'rebuilt.  You can either use the ip or the zonename to identify the\n' +
    'node to remove.  If zonename or ip isn\'t specified, this zonename\n' +
    'will be used.\n' +
    '\n' +
    'Usage:\n' +
    '    {{name}} remove_deposed [OPTIONS]\n' +
    '\n' +
    '{{options}}'
);

cmdln.main(new ManateeAdm(), {showErrStack: true});
