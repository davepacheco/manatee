#!/usr/bin/env node
// -*- mode: js -*-
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */

/*
 * Copyright (c) 2015, Joyent, Inc.
 */
var adm = require('../lib/adm');
var assert = require('assert');
var cmdln = require('cmdln');
var fs = require('fs');
var util = require('util');
var path = require('path');
var tab = require('tab');
var sprintf = require('extsprintf').sprintf;
var VError = require('verror');

/*
 * For consistency in option definitions, any options used by more than one
 * subcommand should be defined here.  Subcommands using these options refer to
 * this definition.
 */
var commonOptions = {
    'help': {
        names: ['help', 'h'],
        type: 'bool',
        help: 'Show this help'
    },
    'ignorePrompts': {
        names: ['ignorePrompts', 'y'],
        type: 'bool',
        helpArg: 'IGNORE_PROMPTS',
        help: 'Skip confirmation prompts (can be dangerous)',
        default: false
    },
    'shard': {
        names: ['shard', 's'],
        type: 'string',
        helpArg: 'SHARD',
        help: 'Name of the Manatee shard (cluster)',
        default: process.env.SHARD
    },
    'zk': {
        names: ['zk', 'z'],
        type: 'string',
        helpArg: 'ZK_IPS',
        help: 'The zookeeper connection string. (e.g., 127.0.0.1:2181)',
        default: process.env.ZK_IPS
    }
};

function ManateeAdm() {
    cmdln.Cmdln.call(this, {
        name: 'manatee-adm',
        desc: 'Inspect and administer a cluster of Manatee peers',
        helpSubcmds: [
	    { 'group': '' },
            { 'group': 'STATUS COMMANDS' },
            'history',
            'pg-status',
            { 'group': 'CLUSTER MAINTENANCE COMMANDS' },
            'freeze',
            'unfreeze',
            'reap',
            'rebuild',
            { 'group': 'UPGRADE COMMANDS' },
            'state-backfill',
            { 'group': 'META COMMANDS' },
            'help',
            'version',
            { 'group': 'DEVELOPER COMMANDS' },
            'set-onwm',
            'zk-state',
            'zk-active',
            { 'group': 'DEPRECATED AND INTERNAL COMMANDS' },
            'check-lock',
            'status',
	    { 'group': '' }
        ]
    });

    this.arg0 = 'manatee-adm';
}
util.inherits(ManateeAdm, cmdln.Cmdln);

/**
 * Emit an error message, then the usage message, and then exit.
 */
ManateeAdm.prototype.usage = function (message, subcmd, cb)
{
    var self = this;

    console.error('%s: %s', self.arg0, message);
    console.error(this.helpFromSubcmd(subcmd));
    process.exit(2);
};

/**
 * Check for a required command-line option.  If option "option" was not
 * specified in "opts", then print an error message, then the usage message,
 * then exit.  This function does not return on failure.
 */
ManateeAdm.prototype.checkRequiredOption = function (subcmd, opts, option, cb)
{
    var self = this;

    if (!opts[option]) {
        self.usage('option is required: --' + option, subcmd, cb);
    }
};

/*
 * Checks whether the "help" option was specified.  If so, print the usage
 * message and exit.  This function does not return if it prints the help
 * message.
 */
ManateeAdm.prototype.checkHelpRequested = function (subcmd, opts, cb)
{
    var self = this;

    if (opts.help) {
        self.do_help('help', {}, [subcmd], cb);
        assert.ok(false, 'internal error: did not expect do_help() to return');
    }
};

/**
 * Prints the version for this manatee-adm.  Taken directly from the
 * package.json.
 */
ManateeAdm.prototype.do_version = function (subcmd, opts, args, cb) {
    var self = this;

    self.checkHelpRequested(subcmd, opts, cb);

    var file = path.resolve(path.dirname(__dirname), 'package.json');
    var error;
    try {
        var s = fs.readFileSync(file);
        var j = JSON.parse(s);
        console.log(j.version);
    } catch (err) {
        error = err;
    }
    return (cb(error));
};
ManateeAdm.prototype.do_version.options = [ commonOptions.help ];
ManateeAdm.prototype.do_version.help = ([
    'Show the version of this Manatee client (from package.json).',
    '',
    'Usage:',
    '    {{name}} version [OPTIONS]',
    '',
    '{{options}}'
].join('\n'));

/**
 * Display the current status of the Manatee cluster(s).
 */
ManateeAdm.prototype.do_status = function (subcmd, opts, args, cb) {
    var self = this;

    self.checkHelpRequested(subcmd, opts, cb);
    self.checkRequiredOption(subcmd, opts, 'zk', cb);

    console.error('note: "%s status" is deprecated. See "%s help pg-status".',
        self.arg0, self.arg0);
    adm.status(opts, function (err, status) {
        if (err) {
            return cb(err);
        } else {
            console.log(JSON.stringify(status));
            return cb();
        }
    });
};
ManateeAdm.prototype.do_status.options = [
    commonOptions.help,
    {
        names: ['legacyOrderMode', 'l'],
        type: 'bool',
        helpArg: 'LEGACY_ORDER_MODE',
        help: 'Show what the status is based on Manatee v1 semantics ' +
            '(ZooKeeper election path) rather than Manatee v2 semantics ' +
            '(persistent cluster state).',
        default: false
    },
    commonOptions.shard,
    commonOptions.zk
];
ManateeAdm.prototype.do_status.help = (
    'Show status of this cluster. See pg-status instead.\n' +
    '\n' +
    'Usage:\n' +
    '    {{name}} status [OPTIONS]\n' +
    '\n' +
    '{{options}}'
);

/**
 * Display the current postgres status for this cluster.  This is a more useful
 * display of the overall cluster status.
 */
ManateeAdm.prototype.do_pg_status = function (subcmd, opts, args, cb) {
    var self = this;
    var period, count;

    self.checkHelpRequested(subcmd, opts, cb);
    self.checkRequiredOption(subcmd, opts, 'shard', cb);
    self.checkRequiredOption(subcmd, opts, 'zk', cb);

    if (args.length > 2) {
        self.usage('unexpected arguments: ' + args.slice(2), subcmd, cb);
    }

    period = null;
    count = null;
    if (args.length > 0) {
        period = parseInt(args[0], 10);
        if (isNaN(period) || period < 1) {
            self.usage('invalid period: "' + args[0] + '"', subcmd, cb);
        }

        if (args.length > 1) {
            count = parseInt(args[1], 10);
            if (isNaN(count) || count < 1) {
                self.usage('invalid count: "' + args[1] + '"', subcmd, cb);
            }
        }
    }

    doPgStatusIter(opts, period, count, cb);
};

ManateeAdm.prototype.do_pg_status.options = [
    commonOptions.help,
    commonOptions.shard,
    commonOptions.zk
];
ManateeAdm.prototype.do_pg_status.help = (
    'Show the postgres status of this cluster. \n' +
    '\n' +
    'Usage:\n' +
    '    {{name}} pg-status [OPTIONS]\n' +
    '\n' +
    '{{options}}'
);

/*
 * Executes "count" iterations of the "pg-status" command, once every "period"
 * seconds, and invoke "cb" on completion.  If "count" is null and "period" is
 * not null, repeat forever.  If "period" is null, don't repeat at all.  This
 * mimics the behavior of the various *stat commands (e.g., mpstat(1M),
 * prstat(1M), and the like).
 */
function doPgStatusIter(opts, period, count, cb)
{
    var self = this;

    adm.loadClusterDetails(opts, function (err, status) {
        if (err) {
            console.error('%s: %s', self.arg0, err.message);
        } else {
            emitClusterDetails(opts, status);
        }

        if (period === null || count == 1)
            return cb(err);

        setTimeout(doPgStatusIter, period * 1000, opts, period, count - 1, cb);
    });
}

/*
 * Given a complete cluster status as returned by adm.loadClusterDetails(),
 * print a human-readable, short summary of the state.
 */
function emitClusterDetails(opts, status)
{
    var columns, rows;

    columns = [ {
        'label': 'ROLE',
        'width': 7
    }, {
        'label': 'HOST',
        'width': 8
    }, {
        'label': 'PG',
        'align': 'left',
        'width': 4
    }, {
        'label': 'REPL',
        'width': 5
    }, {
        'label': 'SENT',
        'width': 10
    }, {
        'label': 'WRITE',
        'width': 10
    }, {
        'label': 'FLUSH',
        'width': 10
    }, {
        'label': 'REPLAY',
        'width': 10
    }, {
        'label': 'LAG',
        'width': 6
    } ];

    rows = [];
    rows.push(rowForPeer('primary', status.pgs_peers[status.pgs_primary]));
    if (status.pgs_sync) {
        rows.push(rowForPeer('sync', status.pgs_peers[status.pgs_sync]));
    }

    status.pgs_asyncs.forEach(function (id) {
        rows.push(rowForPeer('async', status.pgs_peers[id]));
    });

    tab.emitTable({
        'columns': columns,
        'rows': rows
    });

    if (status.pgs_errors.length > 0) {
        console.log('\nCRITICAL ERRORS:');
        status.pgs_errors.forEach(function (err) {
            console.log('    %s', err.message);
        });
        console.log('');
    }

    if (status.pgs_warnings.length > 0) {
        console.log('\nWARNINGS:');
        status.pgs_warnings.forEach(function (err) {
            console.log('    %s', err.message);
        });
        console.log('');
    }
}

/*
 * Returns an object describing a single row emitted by by emitClusterDetails().
 */
function rowForPeer(role, peer)
{
    var rv = {};

    rv['ROLE'] = role;
    rv['HOST'] = peer.pgp_label;

    if (peer.pgp_pgerr !== null) {
        rv['PG'] = 'fail';
        rv['REPL'] = '-';
        rv['SENT'] = '-';
        rv['WRITE'] = '-';
        rv['FLUSH'] = '-';
        rv['REPLAY'] = '-';
        rv['LAG'] = '-';
        return (rv);
    }

    rv['PG'] = 'ok';
    rv['LAG'] = pgDuration(peer.pgp_lag);

    if (peer.pgp_repl === null || !peer.pgp_repl.sync_state) {
        rv['REPL'] = '-';
        rv['SENT'] = '-';
        rv['WRITE'] = '-';
        rv['FLUSH'] = '-';
        rv['REPLAY'] = '-';
        return (rv);
    }

    rv['REPL'] = peer.pgp_repl.sync_state;
    rv['SENT'] = peer.pgp_repl.sent_location;
    rv['WRITE'] = peer.pgp_repl.write_location;
    rv['FLUSH'] = peer.pgp_repl.flush_location;
    rv['REPLAY'] = peer.pgp_repl.replay_location;
    return (rv);
}

/*
 * Given a postgres time duration object "lag", which may have properties like
 * "minutes", "seconds", and the like, return a human readable summary of the
 * duration, like "87m12s".  If the object is null, returns "-".  If the time is
 * not known, returns "?".
 */
function pgDuration(lag)
{
    var minutes, seconds, key;

    if (lag === null)
        return ('-');

    minutes = lag.minutes || 0;
    seconds = lag.seconds || 0;
    for (key in lag) {
        switch (key) {
        case 'days':
            minutes += lag[key] * 24 * 60;
            break;

        case 'hours':
            minutes += lag[key] * 60;
            break;

        case 'minutes':
        case 'seconds':
            break;

        default:
            /*
             * The node-pg-types code that parses postgres intervals implies
             * that it could produce keys for "months" or "years", but
             * empirically it doesn't seem to.  That's a relief (and probably
             * not accidental), since the number of minutes in these units is
             * not constant.  If we get something we don't know about, indicate
             * this to the user.
             */
            return ('?');
        }
    }

    return (sprintf('%dm%02ds', minutes, seconds));
}


/**
 * Display the current cluster state.
 */
ManateeAdm.prototype.do_zk_state = function (subcmd, opts, args, cb) {
    var self = this;

    self.checkHelpRequested(subcmd, opts, cb);
    self.checkRequiredOption(subcmd, opts, 'shard', cb);
    self.checkRequiredOption(subcmd, opts, 'zk', cb);

    adm.zkState(opts, function (err, state) {
        if (err) {
            return cb(err);
        } else {
            console.log(JSON.stringify(state));
            return cb();
        }
    });
};
ManateeAdm.prototype.do_zk_state.options = [
    commonOptions.help,
    commonOptions.shard,
    commonOptions.zk
];
ManateeAdm.prototype.do_zk_state.help = ([
    'Show the raw cluster state stored in ZooKeeper.',
    '',
    'Usage:',
    '    {{name}} zk-state [OPTIONS]',
    '',
    '{{options}}'
].join('\n'));

/**
 * Display the current (raw) active peers for a cluster.
 */
ManateeAdm.prototype.do_zk_active = function (subcmd, opts, args, cb) {
    var self = this;

    self.checkHelpRequested(subcmd, opts, cb);
    self.checkRequiredOption(subcmd, opts, 'shard', cb);
    self.checkRequiredOption(subcmd, opts, 'zk', cb);

    adm.zkActive(opts, function (err, active) {
        if (err) {
            return cb(err);
        } else {
            console.log(JSON.stringify(active));
            return cb();
        }
    });
};
ManateeAdm.prototype.do_zk_active.options = [
    commonOptions.help,
    commonOptions.shard,
    commonOptions.zk
];
ManateeAdm.prototype.do_zk_active.help = ([
    'Show the cluster peers connected to ZooKeeper.',
    '',
    'This may show multiple entries for the same peer when there are multiple',
    'ZooKeeper sessions for that peer (as when it has recently restarted).',
    '',
    'Usage:',
    '    {{name}} zk-active [OPTIONS]',
    '',
    '{{options}}'
].join('\n'));

/**
 * Backfill the cluster state.
 */
ManateeAdm.prototype.do_state_backfill = function (subcmd, opts, args, cb) {
    var self = this;

    self.checkHelpRequested(subcmd, opts, cb);
    self.checkRequiredOption(subcmd, opts, 'shard', cb);
    self.checkRequiredOption(subcmd, opts, 'zk', cb);

    adm.stateBackfill(opts, function (err, state) {
        if (err) {
            return cb(err);
        } else {
            console.log('Ok.');
            return cb();
        }
    });
};
ManateeAdm.prototype.do_state_backfill.options = [
    commonOptions.help,
    commonOptions.shard,
    commonOptions.ignorePrompts,
    commonOptions.zk
];
ManateeAdm.prototype.do_state_backfill.help = ([
    'Backfill the ZooKeeper state for this cluster.',
    '',
    'WARNING: This will only work when no cluster state has been written. It',
    'is only to be used as part of the migration process from Manatee v1 to ',
    'Manatee v2. See the documentation for details.',
    '',
    'Usage:',
    '    {{name}} state-backfill [OPTIONS]',
    '',
    '{{options}}'
].join('\n'));

/**
 * Check the status of a Manatee lock.  This is used by the pg_dump script to
 * determine whether dumps are disabled.  It should probably be renamed to
 * reflect that it's actually checking a configuration property stored in ZK
 * (indicating whether dumps are enabled) and then it should grow a sibling for
 * setting the property.
 */
ManateeAdm.prototype.do_check_lock = function (subcmd, opts, args, cb) {
    var self = this;

    self.checkHelpRequested(subcmd, opts, cb);
    self.checkRequiredOption(subcmd, opts, 'path', cb);
    self.checkRequiredOption(subcmd, opts, 'zk', cb);

    adm.checkLock(opts, function (err, stat) {
        if (err || stat) {
            return cb(new Error('lock exists or unable to get lock'));
        }

        return cb();
    });
};
ManateeAdm.prototype.do_check_lock.options = [
    commonOptions.help,
    {
        names: ['path', 'p'],
        type: 'string',
        helpArg: 'LOCK_PATH',
        help: 'The Manatee lock path in ZK'
    },
    commonOptions.zk
];
ManateeAdm.prototype.do_check_lock.help = (
    'Check the status of a Manatee lock. \n' +
    '\n' +
    'Usage:\n' +
    '    {{name}} check-lock [OPTIONS]\n' +
    '\n' +
    '{{options}}'
);


/**
 * Get the state transition history of the cluster.
 */
ManateeAdm.prototype.do_history = function (subcmd, opts, args, cb) {
    var self = this;
    var histopts;

    self.checkHelpRequested(subcmd, opts, cb);
    self.checkRequiredOption(subcmd, opts, 'shard', cb);
    self.checkRequiredOption(subcmd, opts, 'zk', cb);

    if (opts.sort != 'zkSeq' && opts.sort != 'time') {
        self.usage('-s / --sort must be one of "zkSeq" or "time"', subcmd, cb);
    }

    histopts = {
        'zk': opts.zk,
        'shard': opts.shard,
        'sortByTime': opts.sort == 'time'
    };

    adm.history(histopts, function (err, events) {
        var rows, columns;

        if (err) {
            return cb(err);
        }

        if (opts.json) {
            events.forEach(function (evt) {
                console.log(JSON.stringify({
                    'zkSeq': evt['zkSeq'],
                    'time': evt['time'].toISOString(),
                    'state': evt['state']
                }));
            });
            cb();
            return;
        }

        columns = [ {
            'label': 'TIME',
            'width': 24
        }, {
            'label': 'G#',
            'align': 'right',
            'width': 2
        }, {
            'label': 'MODE',
            'width': 5
        }, {
            'label': 'FRZ',
            'width': 3
        }, {
            'label': 'PRIMARY',
            'width': 8
        }, {
            'label': 'SYNC',
            'width': 8
        }, {
            'label': 'ASYNC',
            'width': 8
        }, {
            'label': 'DEPOSED',
            'width': 8
        } ];

        if (opts.verbose) {
            columns.push({ 'label': 'SUMMARY' });
        }

        rows = events.map(function (evt) {
            var st, p, s, a, d;

            st = evt['state'];
            p = st['primary']['zoneId'];
            s = st['sync'] !== null ? st['sync']['zoneId'] : '-';
            a = st['async'].length === 0 ? '-' :
                st['async'].map(function (async) {
                    return (async['zoneId'].substr(0, 8));
                });
            d = st['deposed'].length === 0 ? '-' :
                st['deposed'].map(function (deposed) {
                    return (deposed['zoneId'].substr(0, 8));
                });

            p = p.substr(0, 8);
            s = s.substr(0, 8);

            return ({
                'TIME': evt['time'].toISOString(),
                'G#': st['generation'],
                'MODE': st['oneNodeWriteMode'] ? 'singl' : 'multi',
                'FRZ': st['freeze'] ? 'frz' : '-',
                'PRIMARY': p,
                'SYNC': s,
                'ASYNC': a,
                'DEPOSED': d,
                'SUMMARY': evt['comment']
            });
        });

        tab.emitTable({
            'columns': columns,
            'rows': rows
        });

        return cb();
    });
};
ManateeAdm.prototype.do_history.options = [
    commonOptions.help,
    {
        names: [ 'json', 'j' ],
        type: 'bool',
        help: 'Emit raw JSON output'
    },
    commonOptions.shard,
    {
        names: [ 'sort' ],
        type: 'string',
        helpArg: 'SORTFIELD',
        help: 'Sort field (either "zkSeq" (default) or "time")',
        default: 'zkSeq'
    },
    {
        names: [ 'verbose', 'v' ],
        type: 'bool',
        help: 'Show human-readable summary of each event'
    },
    commonOptions.zk
];
ManateeAdm.prototype.do_history.help = ([
    'Displays history of state changes for this cluster.',
    '',
    'Usage:',
    '    {{name}} history [OPTIONS]',
    '',
    '{{options}}'
].join('\n'));

/**
 * Rebuild a Manatee peer in a cluster.
 */
ManateeAdm.prototype.do_rebuild = function (subcmd, opts, args, cb) {
    var self = this;

    self.checkHelpRequested(subcmd, opts, cb);
    self.checkRequiredOption(subcmd, opts, 'config', cb);
    self.checkRequiredOption(subcmd, opts, 'zk', cb);

    try {
        var cfg = JSON.parse(fs.readFileSync(opts.config, 'utf8'));
        opts.config = cfg;
    } catch (e) {
        return cb(e);
    }
    adm.rebuild(opts, function (err) {
        if (!err) {
            console.log('Rebuild successful');
        }
        return (cb(err));
    });
};
ManateeAdm.prototype.do_rebuild.options = [
    commonOptions.help,
    {
        names: ['config', 'c'],
        type: 'string',
        helpArg: 'CONFIG',
        help: 'The path to the Manatee sitter config to list',
        default: process.env.MANATEE_SITTER_CONFIG
    },
    commonOptions.ignorePrompts,
    commonOptions.zk
];
ManateeAdm.prototype.do_rebuild.help = ([
    'Rebuild this Manatee peer from the primary peer.' +
    '',
    'Usage:',
    '    {{name}} rebuild [OPTIONS]',
    '',
    '{{options}}'
].join('\n'));

/**
 * Freezes a Manatee's cluster state so that it won't make any state
 * transitions.
 */
ManateeAdm.prototype.do_freeze = function (subcmd, opts, args, cb) {
    var self = this;

    self.checkHelpRequested(subcmd, opts, cb);
    self.checkRequiredOption(subcmd, opts, 'reason', cb);
    self.checkRequiredOption(subcmd, opts, 'shard', cb);
    self.checkRequiredOption(subcmd, opts, 'zk', cb);

    adm.freeze(opts, function (err) {
        if (err) {
            return cb(err);
        }

        console.log('Frozen.');
        return cb();
    });
};
ManateeAdm.prototype.do_freeze.options = [
    commonOptions.help,
    {
        names: ['reason', 'r'],
        type: 'string',
        helpArg: 'REASON',
        help: 'The reason this cluster is being frozen'
    },
    commonOptions.shard,
    commonOptions.zk
];
ManateeAdm.prototype.do_freeze.help = (
    'Freeze this cluster\'s topology. \n' +
    '\n' +
    'Usage:\n' +
    '    {{name}} freeze [OPTIONS]\n' +
    '\n' +
    '{{options}}'
);

/**
 * Unfreezes a Manatee's cluster state so that it will make state transitions.
 */
ManateeAdm.prototype.do_unfreeze = function (subcmd, opts, args, cb) {
    var self = this;

    self.checkHelpRequested(subcmd, opts, cb);
    self.checkRequiredOption(subcmd, opts, 'shard', cb);
    self.checkRequiredOption(subcmd, opts, 'zk', cb);

    adm.unfreeze(opts, function (err) {
        if (err) {
            return cb(err);
        }

        console.log('Unfrozen.');
        return cb();
    });
};
ManateeAdm.prototype.do_unfreeze.options = [
    commonOptions.help,
    commonOptions.shard,
    commonOptions.zk
];
ManateeAdm.prototype.do_unfreeze.help = (
    'Unfreeze this cluster\'s topology. \n' +
    '\n' +
    'Usage:\n' +
    '    {{name}} unfreeze [OPTIONS]\n' +
    '\n' +
    '{{options}}'
);

/**
 * Sets one node write mode.
 */
ManateeAdm.prototype.do_set_onwm = function (subcmd, opts, args, cb) {
    var self = this;

    self.checkHelpRequested(subcmd, opts, cb);
    self.checkRequiredOption(subcmd, opts, 'mode', cb);
    self.checkRequiredOption(subcmd, opts, 'shard', cb);
    self.checkRequiredOption(subcmd, opts, 'zk', cb);

    opts.mode = opts.mode.toLowerCase();
    if (['on', 'off'].indexOf(opts.mode) === -1) {
        self.do_help('help', {}, [subcmd], cb);
    }

    adm.setOnwm(opts, function (err) {
        if (err) {
            return cb(err);
        }

        console.log('One Node Write Mode set to: ' + opts.mode);
        return cb();
    });
};
ManateeAdm.prototype.do_set_onwm.options = [
    commonOptions.help,
    commonOptions.ignorePrompts,
    {
        names: ['mode', 'm'],
        type: 'string',
        helpArg: 'MODE',
        help: 'Must be either "on" or "off"'
    },
    commonOptions.shard,
    commonOptions.zk
];
ManateeAdm.prototype.do_set_onwm.help = ([
    'Enable or disable singleton (one-node-write) mode.',
    '',
    'WARNING: This command must be used very carefully and only if you',
    'really know what you are doing.',
    '',
    'Usage:',
    '    {{name}} set-onwm [OPTIONS]',
    '',
    '{{options}}'
].join('\n'));

/**
 * Removes deposed peers from the Manatee state.
 */
ManateeAdm.prototype.do_reap = function (subcmd, opts, args, cb) {
    var self = this;

    self.checkHelpRequested(subcmd, opts, cb);
    self.checkRequiredOption(subcmd, opts, 'shard', cb);
    self.checkRequiredOption(subcmd, opts, 'zk', cb);

    if (!opts.ip && !opts.zonename) {
        self.checkRequiredOption(subcmd, opts, 'config', cb);

        try {
            var cfg = JSON.parse(fs.readFileSync(opts.config, 'utf8'));
            opts.zonename = cfg.zoneId;
        } catch (e) {
            return cb(e);
        }
    }

    adm.reap(opts, function (err) {
        if (err) {
            return cb(err);
        }

        console.log('Ok.');
        return cb();
    });
};
ManateeAdm.prototype.do_reap.options = [
    commonOptions.help,
    {
        names: ['config', 'c'],
        type: 'string',
        helpArg: 'CONFIG',
        help: 'The path to the Manatee sitter config',
        default: process.env.MANATEE_SITTER_CONFIG
    },
    {
        names: ['ip', 'i'],
        type: 'string',
        helpArg: 'IP',
        help: 'The IP of the peer to reap'
    },
    {
        names: ['zonename', 'n'],
        type: 'string',
        helpArg: 'ZONENAME',
        help: 'The zonename of the peer to reap'
    },
    commonOptions.shard,
    commonOptions.zk
];
ManateeAdm.prototype.do_reap.help = ([
    'Removes a non-existent peer from the list of deposed peers.',
    '',
    'This operation is rarely necessary. It is used when a peer is being',
    'permanently removed from the cluster. This operation only applies to',
    'deposed peers. That\'s because by definition the peer is no longer',
    'present, and absent peers will either become deposed (if they were',
    'primary when they disappeared) or will be removed automatically (if',
    'they had any other role). Deposed peers are the only peers that cannot',
    'be removed automatically because special action must be taken when they',
    'rejoin the cluster.',
    '',
    'You can either use an IP address or a zonename to identify the peer to',
    'reap. If a zonename or IP is not specified, this zone\'s zonename will',
    'be used.',
    '',
    'Usage:',
    '    {{name}} reap [OPTIONS]\n' +
    '',
    '{{options}}'
].join('\n'));

cmdln.main(new ManateeAdm(), {showErrStack: true});
